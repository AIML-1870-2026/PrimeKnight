<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Snake Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            perspective: 1200px;
            transform-style: preserve-3d;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #gameContainer.mode-3d {
            transform-style: preserve-3d;
        }

        #gameContainer.mode-3d canvas {
            transform: rotateX(45deg);
            transform-origin: center bottom;
            transition: transform 0.3s ease;
        }

        canvas {
            border: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            background: #0a0a0a;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(10, 10, 10, 0.95);
            padding: 25px 30px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
            z-index: 10;
        }

        #menu.hidden {
            display: none;
        }

        h1 {
            font-size: 36px;
            margin-bottom: 15px;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }

        .mode-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mode-btn {
            display: block;
            width: 180px;
            margin: 0;
            padding: 12px 10px;
            font-size: 14px;
            background: linear-gradient(135deg, #00ff88, #00aa55);
            border: none;
            border-radius: 5px;
            color: #0a0a0a;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .mode-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        .mode-desc {
            font-size: 10px;
            color: #00ff88;
            margin-top: 3px;
            font-weight: normal;
        }

        #ui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 600px;
            padding: 10px 0;
            margin-top: 10px;
        }

        #ui.hidden {
            display: none;
        }

        #scorePanel {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #score {
            font-size: 20px;
            color: #00ff88;
            font-weight: bold;
        }

        #modeDisplay {
            font-size: 12px;
            color: #e0e0e0;
        }

        #sidePanel {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 11px;
        }

        #sidePanel > div:first-child {
            color: #00ff88;
        }

        .powerup-item {
            display: inline-block;
            padding: 4px 8px;
            background: rgba(0, 255, 136, 0.15);
            border-radius: 3px;
            font-size: 11px;
        }

        .powerup-timer {
            color: #00ff88;
            font-weight: bold;
        }

        #powerupList {
            display: flex;
            gap: 8px;
        }

        #pauseOverlay, #gameOverOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 15;
        }

        #pauseOverlay.hidden, #gameOverOverlay.hidden {
            display: none;
        }

        .overlay-title {
            font-size: 48px;
            color: #00ff88;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        .overlay-btn {
            margin: 10px;
            padding: 15px 40px;
            font-size: 18px;
            background: linear-gradient(135deg, #00ff88, #00aa55);
            border: none;
            border-radius: 5px;
            color: #0a0a0a;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            pointer-events: all;
        }

        .overlay-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        .controls-info {
            margin-top: 0;
            padding: 12px;
            background: rgba(0, 255, 136, 0.05);
            border-radius: 5px;
            font-size: 11px;
            line-height: 1.6;
        }

        .controls-info h3 {
            color: #00ff88;
            margin-bottom: 5px;
            font-size: 12px;
        }

        #finalScore {
            font-size: 36px;
            color: #00ff88;
            margin: 20px 0;
        }

        #layerIndicator {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 20;
            padding: 15px 10px;
            background: rgba(10, 10, 10, 0.9);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        #layerIndicator.hidden {
            display: none;
        }

        .layer-dot {
            width: 40px;
            height: 25px;
            border-radius: 4px;
            opacity: 0.3;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: #000;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .layer-dot:hover {
            opacity: 0.6;
        }

        .layer-dot.active {
            opacity: 1;
            transform: scale(1.2);
            box-shadow: 0 0 15px currentColor;
        }

        .layer-dot.has-food::after {
            content: '‚óè';
            font-size: 8px;
            color: #ff0066;
            position: absolute;
            margin-left: 25px;
        }

        /* Platform toggle buttons */
        .platform-toggle {
            display: flex;
            justify-content: center;
            gap: 0;
            margin-bottom: 15px;
        }

        .toggle-btn {
            padding: 8px 20px;
            font-size: 14px;
            background: #1a1a1a;
            border: 1px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .toggle-btn:first-child {
            border-radius: 5px 0 0 5px;
        }

        .toggle-btn:last-child {
            border-radius: 0 5px 5px 0;
            border-left: none;
        }

        .toggle-btn:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        .toggle-btn.active {
            background: linear-gradient(135deg, #00ff88, #00aa55);
            color: #0a0a0a;
        }

        /* Mobile mode overrides */
        .mobile-mode canvas {
            width: 360px !important;
            height: 360px !important;
        }

        .mobile-mode #ui {
            width: 360px;
            font-size: 11px;
        }

        .mobile-mode #menu {
            padding: 20px;
        }

        .mobile-mode .mode-grid {
            grid-template-columns: 1fr 1fr;
        }

        .mobile-mode .mode-btn {
            width: 140px;
            font-size: 12px;
            padding: 10px 8px;
        }

        .mobile-mode .mode-desc {
            font-size: 9px;
        }

        .mobile-mode h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .mobile-mode .controls-info {
            font-size: 10px;
            padding: 10px;
        }

        .mobile-mode #layerIndicator {
            right: 10px;
            padding: 10px 6px;
        }

        .mobile-mode .layer-dot {
            width: 30px;
            height: 20px;
            font-size: 10px;
        }

        .mobile-mode #score {
            font-size: 16px;
        }

        .mobile-mode #scorePanel {
            gap: 10px;
        }

        .mobile-mode .overlay-title {
            font-size: 36px;
        }

        .mobile-mode .overlay-btn {
            padding: 12px 30px;
            font-size: 14px;
        }

        .mobile-mode #finalScore {
            font-size: 28px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="600" height="600"></canvas>

        <div id="menu">
            <div class="platform-toggle">
                <button id="desktopModeBtn" class="toggle-btn active">Desktop</button>
                <button id="mobileModeBtn" class="toggle-btn">Mobile</button>
            </div>
            <h1>SNAKE</h1>
            <div class="mode-grid">
                <button class="mode-btn" data-mode="classic">
                    Classic
                    <div class="mode-desc">Traditional gameplay</div>
                </button>
                <button class="mode-btn" data-mode="timed">
                    Timed
                    <div class="mode-desc">60-second countdown</div>
                </button>
                <button class="mode-btn" data-mode="survival">
                    Survival
                    <div class="mode-desc">Speed increases</div>
                </button>
                <button class="mode-btn" data-mode="zen">
                    Zen
                    <div class="mode-desc">No death</div>
                </button>
                <button class="mode-btn" data-mode="3d">
                    3D
                    <div class="mode-desc">5 layers</div>
                </button>
                <button class="mode-btn" data-mode="feast">
                    Feast
                    <div class="mode-desc">5 apples</div>
                </button>
                <button class="mode-btn" data-mode="3d-feast">
                    3D Feast
                    <div class="mode-desc">5 layers + 5 apples</div>
                </button>
                <button class="mode-btn" data-mode="zen-feast">
                    Zen Feast
                    <div class="mode-desc">No death + 5 apples</div>
                </button>
                <button class="mode-btn" data-mode="maze">
                    Maze
                    <div class="mode-desc">Pacman-style walls</div>
                </button>
            </div>
            <div class="controls-info">
                <h3>Controls</h3>
                Move: Arrow Keys / WASD / Swipe<br>
                3D Layers: Q/E | Pause: Space / Double-tap
            </div>
        </div>

        <div id="ui" class="hidden">
            <div id="scorePanel">
                <div id="score">Score: 0</div>
                <div id="modeDisplay">Classic Mode</div>
                <div id="timerDisplay" style="color: #ff0066; font-weight: bold;"></div>
                <div id="layerDisplay" style="color: #00ff88;"></div>
            </div>
            <div id="sidePanel">
                <div>Power-Ups:</div>
                <div id="powerupList"></div>
            </div>
        </div>

        <div id="pauseOverlay" class="hidden">
            <div class="overlay-title">PAUSED</div>
            <button class="overlay-btn" onclick="game.togglePause()">Resume</button>
            <button class="overlay-btn" onclick="game.restart()">Restart</button>
            <button class="overlay-btn" onclick="game.returnToMenu()">Main Menu</button>
        </div>

        <div id="gameOverOverlay" class="hidden">
            <div class="overlay-title">GAME OVER</div>
            <div id="finalScore"></div>
            <div id="modePlayedDisplay" style="color: #e0e0e0; margin-bottom: 20px;"></div>
            <button class="overlay-btn" onclick="game.restart()">Play Again</button>
            <button class="overlay-btn" onclick="game.returnToMenu()">Main Menu</button>
        </div>

        <div id="layerIndicator" class="hidden">
            <div class="layer-dot" data-layer="4">5</div>
            <div class="layer-dot" data-layer="3">4</div>
            <div class="layer-dot" data-layer="2">3</div>
            <div class="layer-dot" data-layer="1">2</div>
            <div class="layer-dot" data-layer="0">1</div>
        </div>
    </div>

    <script>
        // Game Configuration
        const CONFIG = {
            gridSize: 25,
            cellSize: 24,
            baseTickRate: 150,
            powerupSpawnChance: 0.15,
            powerupDuration: 8000
        };

        // Layer colors for 3D mode (bottom to top)
        const LAYER_COLORS = [
            { main: '#ff4444', light: '#ff6666', name: 'Red' },      // Layer 1 (bottom)
            { main: '#ff8800', light: '#ffaa44', name: 'Orange' },   // Layer 2
            { main: '#ffdd00', light: '#ffee66', name: 'Yellow' },   // Layer 3 (middle)
            { main: '#44ff88', light: '#88ffaa', name: 'Green' },    // Layer 4
            { main: '#4488ff', light: '#66aaff', name: 'Blue' }      // Layer 5 (top)
        ];

        // Power-up definitions
        const POWERUPS = {
            SPEED: { color: '#ff8800', duration: 5000, name: 'Speed Boost' },
            SLOW: { color: '#0088ff', duration: 5000, name: 'Slow Motion' },
            INVINCIBLE: { color: '#aa00ff', duration: 3000, name: 'Invincibility' },
            MULTIPLIER: { color: '#ffdd00', duration: 10000, name: '2x Points' },
            SHRINK: { color: '#00ff44', instant: true, name: 'Shrink' }
        };

        // Pacman-style maze layout (1 = wall, 0 = path)
        const MAZE_LAYOUT = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1],
            [1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1],
            [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],
            [1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1],
            [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
            [1,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1],
            [1,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1],
            [1,0,1,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,1,0,1],
            [1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1],
            [1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1],
            [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
            [1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1],
            [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1],
            [1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        // Particle system
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 1;
                this.color = color;
                this.size = Math.random() * 3 + 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02;
                this.vx *= 0.98;
                this.vy *= 0.98;
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Main Game Class
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameMode = null;
                this.mobileMode = false;
                this.isPaused = false;
                this.isGameOver = false;
                this.score = 0;
                this.snake = [];
                this.direction = { x: 1, y: 0 };
                this.nextDirection = { x: 1, y: 0 };
                this.foods = [];
                this.powerup = null;
                this.activePowerups = [];
                this.particles = [];
                this.currentLayer = 2; // 3D mode layer (0-4)
                this.tickRate = CONFIG.baseTickRate;
                this.lastTick = 0;
                this.frameCount = 0;
                this.timer = 60;
                this.foodCount = 0;

                this.initEventListeners();
                this.showMenu();
            }

            setMobileMode(enabled) {
                this.mobileMode = enabled;
                const container = document.getElementById('gameContainer');
                const desktopBtn = document.getElementById('desktopModeBtn');
                const mobileBtn = document.getElementById('mobileModeBtn');

                if (enabled) {
                    container.classList.add('mobile-mode');
                    this.canvas.width = 360;
                    this.canvas.height = 360;
                    CONFIG.cellSize = 14.4;
                    desktopBtn.classList.remove('active');
                    mobileBtn.classList.add('active');
                } else {
                    container.classList.remove('mobile-mode');
                    this.canvas.width = 600;
                    this.canvas.height = 600;
                    CONFIG.cellSize = 24;
                    desktopBtn.classList.add('active');
                    mobileBtn.classList.remove('active');
                }

                // Redraw menu if currently showing
                if (!this.gameMode || this.isGameOver) {
                    this.ctx.fillStyle = '#0a0a0a';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
            }

            initEventListeners() {
                // Platform toggle (Desktop/Mobile)
                document.getElementById('desktopModeBtn').addEventListener('click', () => {
                    this.setMobileMode(false);
                });
                document.getElementById('mobileModeBtn').addEventListener('click', () => {
                    this.setMobileMode(true);
                });

                // Mode selection
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.startGame(btn.dataset.mode);
                    });
                });

                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (this.isGameOver) return;

                    // Movement
                    if ((e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') && this.direction.y === 0) {
                        this.nextDirection = { x: 0, y: -1 };
                    } else if ((e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') && this.direction.y === 0) {
                        this.nextDirection = { x: 0, y: 1 };
                    } else if ((e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') && this.direction.x === 0) {
                        this.nextDirection = { x: -1, y: 0 };
                    } else if ((e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') && this.direction.x === 0) {
                        this.nextDirection = { x: 1, y: 0 };
                    }

                    // Layer switching (3D mode)
                    if ((this.gameMode === '3d' || this.gameMode === '3d-feast')) {
                        if ((e.key === 'q' || e.key === 'Q' || e.key === 'j' || e.key === 'J') && this.currentLayer > 0) {
                            this.currentLayer--;
                            this.createLayerSwitchEffect();
                        } else if ((e.key === 'e' || e.key === 'E' || e.key === 'k' || e.key === 'K') && this.currentLayer < 4) {
                            this.currentLayer++;
                            this.createLayerSwitchEffect();
                        }
                    }

                    // Game controls
                    if (e.key === ' ') {
                        e.preventDefault();
                        this.togglePause();
                    } else if (e.key === 'r' || e.key === 'R') {
                        this.restart();
                    } else if (e.key === 'Escape') {
                        this.returnToMenu();
                    }
                });

                // Touch controls for mobile
                let touchStartX = 0;
                let touchStartY = 0;
                let touchStartTime = 0;

                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    touchStartTime = Date.now();
                }, { passive: false });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (this.isGameOver || this.isPaused) return;

                    const touch = e.changedTouches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;
                    const deltaTime = Date.now() - touchStartTime;

                    // Minimum swipe distance and max time
                    const minSwipe = 30;
                    const maxTime = 500;

                    if (deltaTime > maxTime) return;

                    // Determine swipe direction
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // Horizontal swipe
                        if (Math.abs(deltaX) > minSwipe) {
                            if (deltaX > 0 && this.direction.x === 0) {
                                this.nextDirection = { x: 1, y: 0 }; // Right
                            } else if (deltaX < 0 && this.direction.x === 0) {
                                this.nextDirection = { x: -1, y: 0 }; // Left
                            }
                        }
                    } else {
                        // Vertical swipe
                        if (Math.abs(deltaY) > minSwipe) {
                            if (deltaY > 0 && this.direction.y === 0) {
                                this.nextDirection = { x: 0, y: 1 }; // Down
                            } else if (deltaY < 0 && this.direction.y === 0) {
                                this.nextDirection = { x: 0, y: -1 }; // Up
                            }
                        }
                    }
                }, { passive: false });

                // Double tap to pause
                let lastTap = 0;
                this.canvas.addEventListener('touchend', (e) => {
                    const now = Date.now();
                    if (now - lastTap < 300) {
                        this.togglePause();
                    }
                    lastTap = now;
                });

                // Layer dot click/tap to switch layers
                document.querySelectorAll('.layer-dot').forEach(dot => {
                    dot.addEventListener('click', (e) => {
                        if (!(this.gameMode === '3d' || this.gameMode === '3d-feast')) return;
                        const targetLayer = parseInt(dot.dataset.layer);
                        if (targetLayer !== this.currentLayer) {
                            this.currentLayer = targetLayer;
                            this.createLayerSwitchEffect();
                        }
                    });
                });
            }

            startGame(mode) {
                this.gameMode = mode;
                this.isGameOver = false;
                this.isPaused = false;
                this.score = 0;
                this.foodCount = 0;
                this.currentLayer = 2;
                this.particles = [];
                this.activePowerups = [];
                this.powerup = null;
                this.tickRate = mode === 'maze' ? CONFIG.baseTickRate * 4 : CONFIG.baseTickRate;
                this.timer = 60;
                this.layerFlash = 0;

                // Initialize snake (different starting position for maze mode)
                if (mode === 'maze') {
                    this.snake = [
                        { x: 5, y: 1, layer: this.currentLayer },
                        { x: 4, y: 1, layer: this.currentLayer },
                        { x: 3, y: 1, layer: this.currentLayer }
                    ];
                } else {
                    this.snake = [
                        { x: 12, y: 12, layer: this.currentLayer },
                        { x: 11, y: 12, layer: this.currentLayer },
                        { x: 10, y: 12, layer: this.currentLayer }
                    ];
                }
                this.direction = { x: 1, y: 0 };
                this.nextDirection = { x: 1, y: 0 };

                // Initialize and spawn food
                this.foods = [];
                const foodCount = (mode === 'feast' || mode === '3d-feast' || mode === 'zen-feast') ? 5 : 1;
                for (let i = 0; i < foodCount; i++) {
                    this.spawnFood();
                }

                // Hide menu, show UI
                document.getElementById('menu').classList.add('hidden');
                document.getElementById('ui').classList.remove('hidden');

                // Apply 3D tilt for 3D mode
                const container = document.getElementById('gameContainer');
                const layerIndicator = document.getElementById('layerIndicator');
                if ((mode === '3d' || mode === '3d-feast')) {
                    container.classList.add('mode-3d');
                    layerIndicator.classList.remove('hidden');
                    this.updateLayerIndicator();
                } else {
                    container.classList.remove('mode-3d');
                    layerIndicator.classList.add('hidden');
                }

                this.updateUI();
                this.gameLoop();
            }

            gameLoop(timestamp = 0) {
                if (this.isGameOver) return;

                // Update
                if (!this.isPaused) {
                    // Game tick
                    if (timestamp - this.lastTick >= this.tickRate) {
                        this.tick();
                        this.lastTick = timestamp;
                    }

                    // Update particles
                    this.particles = this.particles.filter(p => {
                        p.update();
                        return p.life > 0;
                    });

                    // Decay layer flash
                    if (this.layerFlash > 0) {
                        this.layerFlash -= 0.05;
                    }

                    // Update powerups
                    this.updatePowerups();

                    // Timer for timed mode
                    if (this.gameMode === 'timed') {
                        this.frameCount++;
                        if (this.frameCount >= 60) {
                            this.timer--;
                            this.frameCount = 0;
                            if (this.timer <= 0) {
                                this.endGame();
                            }
                        }
                    }
                }

                // Render
                this.render();
                this.updateUI();

                requestAnimationFrame((ts) => this.gameLoop(ts));
            }

            tick() {
                // Update direction
                this.direction = { ...this.nextDirection };

                // Move snake
                const head = { ...this.snake[0] };
                head.x += this.direction.x;
                head.y += this.direction.y;
                head.layer = this.currentLayer;

                // Zen mode wrapping
                if (this.gameMode === 'zen' || this.gameMode === 'zen-feast') {
                    if (head.x < 0) head.x = CONFIG.gridSize - 1;
                    if (head.x >= CONFIG.gridSize) head.x = 0;
                    if (head.y < 0) head.y = CONFIG.gridSize - 1;
                    if (head.y >= CONFIG.gridSize) head.y = 0;
                } else if (this.gameMode === 'maze') {
                    // Maze tunnel wrapping (left/right edges)
                    if (head.x < 0) {
                        head.x = CONFIG.gridSize - 1;
                        // If wrapped into a wall, skip this tick (stay in place)
                        if (MAZE_LAYOUT[head.y][head.x] === 1) {
                            return;
                        }
                    } else if (head.x >= CONFIG.gridSize) {
                        head.x = 0;
                        if (MAZE_LAYOUT[head.y][head.x] === 1) {
                            return;
                        }
                    }
                    // Top/bottom boundary - skip tick (stay in place)
                    if (head.y < 0 || head.y >= CONFIG.gridSize) {
                        return;
                    }
                    // Maze wall collision - skip tick instead of dying
                    if (MAZE_LAYOUT[head.y] && MAZE_LAYOUT[head.y][head.x] === 1) {
                        return;
                    }
                } else {
                    // Wall collision
                    if (head.x < 0 || head.x >= CONFIG.gridSize || head.y < 0 || head.y >= CONFIG.gridSize) {
                        this.endGame();
                        return;
                    }
                }

                // Self collision
                const hasInvincibility = this.activePowerups.some(p => p.type === 'INVINCIBLE');
                if (!hasInvincibility && this.gameMode !== 'zen' && this.gameMode !== 'zen-feast') {
                    for (let i = 0; i < this.snake.length; i++) {
                        const segment = this.snake[i];
                        if ((this.gameMode === '3d' || this.gameMode === '3d-feast')) {
                            // Only check collision on same layer
                            if (segment.x === head.x && segment.y === head.y && segment.layer === head.layer) {
                                this.endGame();
                                return;
                            }
                        } else {
                            if (segment.x === head.x && segment.y === head.y) {
                                this.endGame();
                                return;
                            }
                        }
                    }
                }

                this.snake.unshift(head);

                // Food collision - check against all foods
                let eatenFoodIndex = -1;
                for (let i = 0; i < this.foods.length; i++) {
                    const food = this.foods[i];
                    if ((this.gameMode === '3d' || this.gameMode === '3d-feast')) {
                        if (head.x === food.x && head.y === food.y && head.layer === food.layer) {
                            eatenFoodIndex = i;
                            break;
                        }
                    } else {
                        if (head.x === food.x && head.y === food.y) {
                            eatenFoodIndex = i;
                            break;
                        }
                    }
                }

                if (eatenFoodIndex !== -1) {
                    const multiplier = this.activePowerups.some(p => p.type === 'MULTIPLIER') ? 2 : 1;
                    this.score += 10 * multiplier;
                    this.foodCount++;
                    this.createFoodParticles(head.x, head.y);

                    // Remove eaten food and spawn new one
                    this.foods.splice(eatenFoodIndex, 1);
                    this.spawnFood();

                    // Survival mode speed increase
                    if (this.gameMode === 'survival' && this.foodCount % 5 === 0) {
                        this.tickRate = Math.max(50, this.tickRate * 0.9);
                    }

                    // Spawn powerup
                    if (Math.random() < CONFIG.powerupSpawnChance && !this.powerup) {
                        this.spawnPowerup();
                    }
                } else {
                    this.snake.pop();
                }

                // Powerup collision
                if (this.powerup) {
                    let gotPowerup = false;
                    if ((this.gameMode === '3d' || this.gameMode === '3d-feast')) {
                        gotPowerup = head.x === this.powerup.x && head.y === this.powerup.y && head.layer === this.powerup.layer;
                    } else {
                        gotPowerup = head.x === this.powerup.x && head.y === this.powerup.y;
                    }

                    if (gotPowerup) {
                        this.collectPowerup();
                    }
                }
            }

            spawnFood() {
                let x, y, layer;
                do {
                    x = Math.floor(Math.random() * CONFIG.gridSize);
                    y = Math.floor(Math.random() * CONFIG.gridSize);
                    layer = (this.gameMode === '3d' || this.gameMode === '3d-feast') ? Math.floor(Math.random() * 5) : this.currentLayer;
                } while (
                    this.snake.some(s => s.x === x && s.y === y && s.layer === layer) ||
                    this.foods.some(f => f.x === x && f.y === y && f.layer === layer) ||
                    (this.gameMode === 'maze' && MAZE_LAYOUT[y][x] === 1)
                );

                this.foods.push({ x, y, layer });

                if ((this.gameMode === '3d' || this.gameMode === '3d-feast')) {
                    this.updateLayerIndicator();
                }
            }

            spawnPowerup() {
                const types = Object.keys(POWERUPS);
                const type = types[Math.floor(Math.random() * types.length)];

                let x, y, layer;
                do {
                    x = Math.floor(Math.random() * CONFIG.gridSize);
                    y = Math.floor(Math.random() * CONFIG.gridSize);
                    layer = (this.gameMode === '3d' || this.gameMode === '3d-feast') ? Math.floor(Math.random() * 5) : this.currentLayer;
                } while (
                    this.snake.some(s => s.x === x && s.y === y && s.layer === layer) ||
                    this.foods.some(f => f.x === x && f.y === y && f.layer === layer) ||
                    (this.gameMode === 'maze' && MAZE_LAYOUT[y][x] === 1)
                );

                this.powerup = { x, y, layer, type, spawnTime: Date.now() };
            }

            collectPowerup() {
                const type = this.powerup.type;
                const config = POWERUPS[type];

                this.createPowerupParticles(this.powerup.x, this.powerup.y, config.color);
                this.screenShake();

                if (type === 'SHRINK') {
                    const removeCount = Math.min(3, this.snake.length - 3);
                    for (let i = 0; i < removeCount; i++) {
                        this.snake.pop();
                    }
                } else {
                    this.activePowerups.push({
                        type: type,
                        endTime: Date.now() + config.duration
                    });

                    if (type === 'SPEED') {
                        this.tickRate = CONFIG.baseTickRate / 1.5;
                    } else if (type === 'SLOW') {
                        this.tickRate = CONFIG.baseTickRate * 2;
                    }
                }

                this.powerup = null;
            }

            updatePowerups() {
                const now = Date.now();
                this.activePowerups = this.activePowerups.filter(p => now < p.endTime);

                // Reset tick rate if no speed modifiers
                if (!this.activePowerups.some(p => p.type === 'SPEED' || p.type === 'SLOW')) {
                    if (this.gameMode === 'survival') {
                        this.tickRate = CONFIG.baseTickRate * Math.pow(0.9, Math.floor(this.foodCount / 5));
                    } else {
                        this.tickRate = CONFIG.baseTickRate;
                    }
                }

                // Remove expired powerups
                if (this.powerup && now - this.powerup.spawnTime > CONFIG.powerupDuration) {
                    this.powerup = null;
                }
            }

            createFoodParticles(x, y) {
                const centerX = x * CONFIG.cellSize + CONFIG.cellSize / 2;
                const centerY = y * CONFIG.cellSize + CONFIG.cellSize / 2;
                for (let i = 0; i < 10; i++) {
                    this.particles.push(new Particle(centerX, centerY, '#ff0066'));
                }
            }

            createPowerupParticles(x, y, color) {
                const centerX = x * CONFIG.cellSize + CONFIG.cellSize / 2;
                const centerY = y * CONFIG.cellSize + CONFIG.cellSize / 2;
                for (let i = 0; i < 20; i++) {
                    this.particles.push(new Particle(centerX, centerY, color));
                }
            }

            createLayerSwitchEffect() {
                const head = this.snake[0];
                const centerX = head.x * CONFIG.cellSize + CONFIG.cellSize / 2;
                const centerY = head.y * CONFIG.cellSize + CONFIG.cellSize / 2;
                const layerColor = LAYER_COLORS[this.currentLayer].main;
                for (let i = 0; i < 12; i++) {
                    this.particles.push(new Particle(centerX, centerY, layerColor));
                }
                this.layerFlash = 1.0; // Trigger flash effect
                this.updateLayerIndicator();
            }

            updateLayerIndicator() {
                const dots = document.querySelectorAll('.layer-dot');
                dots.forEach(dot => {
                    const layer = parseInt(dot.dataset.layer);
                    dot.style.backgroundColor = LAYER_COLORS[layer].main;
                    dot.style.color = layer > 2 ? '#000' : '#fff';

                    if (layer === this.currentLayer) {
                        dot.classList.add('active');
                    } else {
                        dot.classList.remove('active');
                    }

                    // Show food indicator
                    if (this.foods && this.foods.some(f => f.layer === layer)) {
                        dot.classList.add('has-food');
                    } else {
                        dot.classList.remove('has-food');
                    }
                });
            }

            screenShake() {
                const container = document.getElementById('gameContainer');
                container.style.transform = 'translate(3px, 3px)';
                setTimeout(() => {
                    container.style.transform = 'translate(-3px, -3px)';
                    setTimeout(() => {
                        container.style.transform = '';
                    }, 50);
                }, 50);
            }

            render() {
                const ctx = this.ctx;

                // Clear with fade effect
                ctx.fillStyle = 'rgba(10, 10, 10, 0.3)';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw grid
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 1;
                for (let i = 0; i <= CONFIG.gridSize; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * CONFIG.cellSize, 0);
                    ctx.lineTo(i * CONFIG.cellSize, this.canvas.height);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i * CONFIG.cellSize);
                    ctx.lineTo(this.canvas.width, i * CONFIG.cellSize);
                    ctx.stroke();
                }

                // Draw maze walls
                if (this.gameMode === 'maze') {
                    ctx.fillStyle = '#0044aa';
                    ctx.shadowColor = '#0066ff';
                    ctx.shadowBlur = 8;
                    for (let y = 0; y < CONFIG.gridSize; y++) {
                        for (let x = 0; x < CONFIG.gridSize; x++) {
                            if (MAZE_LAYOUT[y][x] === 1) {
                                ctx.fillRect(
                                    x * CONFIG.cellSize + 1,
                                    y * CONFIG.cellSize + 1,
                                    CONFIG.cellSize - 2,
                                    CONFIG.cellSize - 2
                                );
                            }
                        }
                    }
                    ctx.shadowBlur = 0;
                }

                // 3D Mode: Draw all layers with depth effects
                if ((this.gameMode === '3d' || this.gameMode === '3d-feast')) {
                    // Draw layers from back to front (furthest first)
                    const layerOrder = [];
                    for (let i = 0; i < 5; i++) {
                        layerOrder.push(i);
                    }
                    // Sort so current layer is drawn last (on top)
                    layerOrder.sort((a, b) => {
                        if (a === this.currentLayer) return 1;
                        if (b === this.currentLayer) return -1;
                        return Math.abs(a - this.currentLayer) - Math.abs(b - this.currentLayer);
                    });

                    layerOrder.forEach(layer => {
                        if (layer === this.currentLayer) return; // Draw current layer separately

                        const layerDiff = layer - this.currentLayer;
                        const distance = Math.abs(layerDiff);
                        const opacity = Math.max(0.15, 0.6 - distance * 0.15);
                        const scale = 1 - distance * 0.08;
                        const yOffset = layerDiff * 25; // Vertical offset for depth
                        const layerColor = LAYER_COLORS[layer];

                        ctx.globalAlpha = opacity;

                        // Draw layer background tint
                        ctx.fillStyle = layerColor.main;
                        ctx.globalAlpha = 0.03;
                        ctx.fillRect(0, yOffset, this.canvas.width, this.canvas.height);
                        ctx.globalAlpha = opacity;

                        // Draw foods on this layer
                        this.foods.forEach(food => {
                            if (food.layer === layer) {
                                ctx.fillStyle = layerColor.main;
                                const size = (CONFIG.cellSize - 8) * scale;
                                const offset = (CONFIG.cellSize - size) / 2;
                                ctx.fillRect(
                                    food.x * CONFIG.cellSize + offset,
                                    food.y * CONFIG.cellSize + offset + yOffset,
                                    size,
                                    size
                                );
                            }
                        });

                        // Draw snake segments on this layer
                        this.snake.forEach((segment, index) => {
                            if (segment.layer === layer) {
                                ctx.fillStyle = layerColor.main;
                                const size = (CONFIG.cellSize - 6) * scale;
                                const offset = (CONFIG.cellSize - size) / 2;
                                ctx.fillRect(
                                    segment.x * CONFIG.cellSize + offset,
                                    segment.y * CONFIG.cellSize + offset + yOffset,
                                    size,
                                    size
                                );
                            }
                        });
                    });

                    ctx.globalAlpha = 1;

                    // Draw current layer border indicator
                    const currentColor = LAYER_COLORS[this.currentLayer];
                    ctx.strokeStyle = currentColor.main;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(2, 2, this.canvas.width - 4, this.canvas.height - 4);
                    ctx.lineWidth = 1;
                }

                // Draw foods on current layer
                this.foods.forEach(food => {
                    if (!(this.gameMode === '3d' || this.gameMode === '3d-feast') || food.layer === this.currentLayer) {
                        const foodPulse = Math.sin(Date.now() / 200) * 0.25 + 1;
                        const is3DMode = (this.gameMode === '3d' || this.gameMode === '3d-feast');
                        const foodColor = is3DMode ? LAYER_COLORS[food.layer].main : '#ff0066';
                        ctx.save();
                        ctx.shadowColor = foodColor;
                        ctx.shadowBlur = 15 * foodPulse;
                        ctx.fillStyle = foodColor;
                        ctx.fillRect(
                            food.x * CONFIG.cellSize + 4,
                            food.y * CONFIG.cellSize + 4,
                            CONFIG.cellSize - 8,
                            CONFIG.cellSize - 8
                        );
                        ctx.restore();
                    }
                });

                // Draw powerup
                if (this.powerup) {
                    const shouldDraw = !(this.gameMode === '3d' || this.gameMode === '3d-feast') || this.powerup.layer === this.currentLayer;
                    if (shouldDraw) {
                        const config = POWERUPS[this.powerup.type];
                        const pulse = Math.sin(Date.now() / 150) * 0.3 + 1;
                        ctx.save();
                        ctx.shadowColor = config.color;
                        ctx.shadowBlur = 20 * pulse;
                        ctx.fillStyle = config.color;
                        ctx.beginPath();
                        ctx.arc(
                            this.powerup.x * CONFIG.cellSize + CONFIG.cellSize / 2,
                            this.powerup.y * CONFIG.cellSize + CONFIG.cellSize / 2,
                            CONFIG.cellSize / 3 * pulse,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        ctx.restore();
                    }
                }

                // Draw snake on current layer
                this.snake.forEach((segment, index) => {
                    const shouldDraw = !(this.gameMode === '3d' || this.gameMode === '3d-feast') || segment.layer === this.currentLayer;
                    if (!shouldDraw) return;

                    const alpha = 1 - (index / this.snake.length) * 0.5;

                    // Use layer color in 3D mode
                    let color1, color2;
                    if ((this.gameMode === '3d' || this.gameMode === '3d-feast')) {
                        const layerColor = LAYER_COLORS[this.currentLayer];
                        color1 = layerColor.main;
                        color2 = layerColor.light;
                    } else {
                        color1 = '#00ff88';
                        color2 = '#00aa55';
                    }

                    const gradient = ctx.createLinearGradient(
                        segment.x * CONFIG.cellSize,
                        segment.y * CONFIG.cellSize,
                        (segment.x + 1) * CONFIG.cellSize,
                        (segment.y + 1) * CONFIG.cellSize
                    );

                    // Parse hex to rgba
                    const hexToRgba = (hex, a) => {
                        const r = parseInt(hex.slice(1, 3), 16);
                        const g = parseInt(hex.slice(3, 5), 16);
                        const b = parseInt(hex.slice(5, 7), 16);
                        return `rgba(${r}, ${g}, ${b}, ${a})`;
                    };

                    gradient.addColorStop(0, hexToRgba(color1, alpha));
                    gradient.addColorStop(1, hexToRgba(color2, alpha));

                    ctx.fillStyle = gradient;

                    // Head glow
                    if (index === 0) {
                        ctx.save();
                        ctx.shadowColor = color1;
                        ctx.shadowBlur = 15;

                        // Active powerup glow
                        if (this.activePowerups.length > 0) {
                            const powerup = this.activePowerups[0];
                            ctx.shadowColor = POWERUPS[powerup.type].color;
                            ctx.shadowBlur = 20;
                        }
                    }

                    ctx.fillRect(
                        segment.x * CONFIG.cellSize + 2,
                        segment.y * CONFIG.cellSize + 2,
                        CONFIG.cellSize - 6,
                        CONFIG.cellSize - 6
                    );

                    if (index === 0) ctx.restore();
                });

                // Draw layer transition flash
                if ((this.gameMode === '3d' || this.gameMode === '3d-feast') && this.layerFlash > 0) {
                    const layerColor = LAYER_COLORS[this.currentLayer].main;
                    ctx.fillStyle = layerColor;
                    ctx.globalAlpha = this.layerFlash * 0.3;
                    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    ctx.globalAlpha = 1;
                }

                // Draw particles
                this.particles.forEach(p => p.draw(ctx));
            }

            updateUI() {
                document.getElementById('score').textContent = `Score: ${this.score}`;

                const modeNames = {
                    'classic': 'Classic Mode',
                    'timed': 'Timed Challenge',
                    'survival': 'Survival Mode',
                    'zen': 'Zen Mode',
                    '3d': '3D Mode',
                    'feast': 'Feast Mode',
                    '3d-feast': '3D Feast Mode',
                    'zen-feast': 'Zen Feast Mode',
                    'maze': 'Maze Mode'
                };
                document.getElementById('modeDisplay').textContent = modeNames[this.gameMode] || '';

                // Timer display
                const timerDisplay = document.getElementById('timerDisplay');
                if (this.gameMode === 'timed') {
                    timerDisplay.textContent = `Time: ${this.timer}s`;
                    timerDisplay.style.display = 'block';
                } else {
                    timerDisplay.style.display = 'none';
                }

                // Layer display
                const layerDisplay = document.getElementById('layerDisplay');
                if ((this.gameMode === '3d' || this.gameMode === '3d-feast')) {
                    layerDisplay.textContent = `Layer: ${this.currentLayer + 1}/5`;
                    layerDisplay.style.display = 'block';
                } else {
                    layerDisplay.style.display = 'none';
                }

                // Powerup list
                const powerupList = document.getElementById('powerupList');
                if (this.activePowerups.length > 0) {
                    powerupList.innerHTML = this.activePowerups.map(p => {
                        const remaining = Math.ceil((p.endTime - Date.now()) / 1000);
                        return `<span class="powerup-item">${POWERUPS[p.type].name} <span class="powerup-timer">${remaining}s</span></span>`;
                    }).join('');
                } else {
                    powerupList.innerHTML = '<span style="color: #666;">None</span>';
                }
            }

            togglePause() {
                if (this.isGameOver) return;
                this.isPaused = !this.isPaused;
                document.getElementById('pauseOverlay').classList.toggle('hidden', !this.isPaused);
            }

            restart() {
                document.getElementById('pauseOverlay').classList.add('hidden');
                document.getElementById('gameOverOverlay').classList.add('hidden');
                this.startGame(this.gameMode);
            }

            returnToMenu() {
                this.isGameOver = true;
                this.isPaused = false;
                document.getElementById('pauseOverlay').classList.add('hidden');
                document.getElementById('gameOverOverlay').classList.add('hidden');
                this.showMenu();
            }

            showMenu() {
                document.getElementById('menu').classList.remove('hidden');
                document.getElementById('ui').classList.add('hidden');
                document.getElementById('layerIndicator').classList.add('hidden');

                // Remove 3D tilt
                document.getElementById('gameContainer').classList.remove('mode-3d');

                // Clear canvas
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            endGame() {
                this.isGameOver = true;

                // Remove 3D tilt so overlay displays properly
                document.getElementById('gameContainer').classList.remove('mode-3d');
                document.getElementById('layerIndicator').classList.add('hidden');

                // Add bonus for snake length
                this.score += this.snake.length;

                document.getElementById('finalScore').textContent = `Final Score: ${this.score}`;
                const modeNames = {
                    'classic': 'Classic Mode',
                    'timed': 'Timed Challenge',
                    'survival': 'Survival Mode',
                    'zen': 'Zen Mode',
                    '3d': '3D Mode',
                    'feast': 'Feast Mode',
                    '3d-feast': '3D Feast Mode',
                    'zen-feast': 'Zen Feast Mode',
                    'maze': 'Maze Mode'
                };
                document.getElementById('modePlayedDisplay').textContent = modeNames[this.gameMode];
                document.getElementById('gameOverOverlay').classList.remove('hidden');
            }
        }

        // Initialize game
        let game;
        window.addEventListener('DOMContentLoaded', () => {
            game = new Game();
        });
    </script>
</body>
</html>
